---
author: appleboy
type: post
date: -001-11-30T00:00:00+00:00
draft: true
url: /?p=7487
categories:
  - blog

---
<pre><code class="language-go">func main() {
    c := make(chan bool)
    go func() {
        fmt.Println("GO GO GO")
        c &lt;- true
        c &lt;- true
        fmt.Println("end")
    }()
    &lt;-c
    time.Sleep(1 * time.Second)
}</code></pre>

<pre><code class="language-go">func worker(jobChan &lt;-chan Job) {
    for job := range jobChan {
        process(job)
    }
}

// make a channel with a capacity of 1024.
jobChan := make(chan Job, 1024)

// start the worker
go worker(jobChan)

// enqueue a job
jobChan &lt;- job</code></pre>

<pre><code class="language-go">func Enqueue(job Job, jobChan &lt;-chan Job) bool {
    select {
    case jobChan &lt;- job:
        return true
    default:
        return false
    }
}

if !Enqueue(job, chan) {
    Error(
        http.StatusServiceUnavailable, 
        "max capacity reached",
    )
    return
}</code></pre>

<pre><code class="language-go">func main() {
    // c := make(chan bool, 1)
    // go func() {
    //  fmt.Println("GO GO GO")
    //  &lt;-c
    //  time.Sleep(1 * time.Second)
    // }()
    // fmt.Println("main over")
    // c &lt;- true

    ch := make(chan int, 2)
    go func() {
        ch &lt;- 1
        ch &lt;- 2
        close(ch)
    }()

    for n := range ch {
        fmt.Println(n)
    }

    // time.Sleep(2 * time.Second)
}</code></pre>

<pre><code class="language-go">func main() {
    ch := make(chan int, 2)
    go func() {
        ch &lt;- 1
        ch &lt;- 2
    }()

    go func() {
        for n := range ch {
            fmt.Println(n)
        }
    }()

    time.Sleep(2 * time.Second)
}</code></pre>

<pre><code class="language-go">type Consumer struct {
    inputChan chan int
    jobsChan  chan int
}

func (c Consumer) callbackFunc(event int) {
    c.inputChan &lt;- event
}

func main() {
    // create the consumer
    consumer := Consumer{
        inputChan: make(chan int, 1),
        jobsChan:  make(chan int, workerPoolSize),
    }
}</code></pre>

<pre><code class="language-go">func WithContextFunc(ctx context.Context, f func()) context.Context {
    ctx, cancel := context.WithCancel(ctx)
    go func() {
        c := make(chan os.Signal)
        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
        defer signal.Stop(c)

        select {
        case &lt;-ctx.Done():
        case &lt;-c:
            f()
            cancel()
        }
    }()

    return ctx
}</code></pre>

<pre><code class="language-go">func (c Consumer) startConsumer(ctx context.Context) {
    for {
        select {
        case job := &lt;-c.inputChan:
            if ctx.Err() != nil {
                fmt.Println("get done with input channel at the same time")
                close(c.jobsChan)
                return
            }
            c.jobsChan &lt;- job
        case &lt;-ctx.Done():
            fmt.Println("Consumer received cancellation signal, closing jobsChan!")
            close(c.jobsChan)
            fmt.Println("Consumer closed jobsChan")
            return
        }
    }
}</code></pre>

<pre><code class="language-go">func (c Consumer) workerFunc() {
    for eventIndex := range c.jobsChan {
        // handle the job event
    }
}

func (c Consumer) workerFunc(wg *sync.WaitGroup, index int) {
    defer wg.Done()
    for eventIndex := range c.jobsChan {
        // handle the job event
    }
}</code></pre>

<pre><code class="language-go">    wg := &sync.WaitGroup{}
    wg.Add(numberOfWorkers)

    // Start [workerPoolSize] workers
    for i := 0; i &lt; workerPoolSize; i++ {
        go workerFunc(wg)
    }</code></pre>

<pre><code class="language-go">    wg := &sync.WaitGroup{}
    wg.Add(numberOfWorkers)
    ctx := signal.WithContextFunc(
        context.Background(),
        func() {
            wg.Wait()
        },
    )
    // Start consumer with cancellation context passed
    go consumer.startConsumer(ctx)</code></pre>

<pre><code class="language-go">// create a cancel channel
cancelChan := make(chan struct{})

// start the goroutine passing it the cancel channel 
go worker(jobChan, cancelChan)

func worker(jobChan &lt;-chan Job, cancelChan &lt;-chan struct{}) {
    for {
        select {
        case &lt;-cancelChan:
            return

        case job := &lt;-jobChan:
            process(job)
        }
    }
}

// to cancel the worker, close the cancel channel
close(cancelChan)</code></pre>

<pre><code class="language-go">        r := e.Group("/rpc")
        r.Use(rpc.Check())
        {
            r.POST("/v1/healthz", web.RPCHeartbeat)
            r.POST("/v1/request", web.RPCRquest)
            r.POST("/v1/accept", web.RPCAccept)
            r.POST("/v1/details", web.RPCDetails)
            r.POST("/v1/updateStatus", web.RPCUpdateStatus)
            r.POST("/v1/upload", web.RPCUploadBytes)
            r.POST("/v1/reset", web.RPCResetStatus)
        }</code></pre>

<pre><code class="language-go">    if r.Capacity != 0 {
        var g errgroup.Group
        for i := 0; i &lt; r.Capacity; i++ {
            g.Go(func() error {
                return r.start(ctx, 0)
            })
            time.Sleep(1 * time.Second)
        }
        return g.Wait()
    }</code></pre>

<pre><code class="language-go">func (r *Runner) start(ctx context.Context, id int64) error {
LOOP:
    for {
        select {
        case &lt;-ctx.Done():
            return ctx.Err()
        default:
            r.poll(ctx, id)

            if r.Capacity == 0 {
                break LOOP
            }
        }
        time.Sleep(1 * time.Second)
    }

    return nil
}</code></pre>

<pre><code class="language-go">    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    timeout, cancel := context.WithTimeout(ctx, 60*time.Minute)
    defer cancel()

    go func() {
        done, _ := r.Manager.Watch(ctx, id)
        if done {
            cancel()
        }
    }()</code></pre>

<pre><code class="language-go">        subscribers: make(map[chan struct{}]int64),
        cancelled:   make(map[int64]time.Time),

    c.Lock()
    c.cancelled[id] = time.Now().Add(time.Minute * 5)
    for subscriber, build := range c.subscribers {
        if id == build {
            close(subscriber)
        }
    }
    c.collect()
    c.Unlock()
    return nil</code></pre>

<pre><code class="language-go">    for {
        select {
        case &lt;-ctx.Done():
            return false, ctx.Err()
        case &lt;-time.After(time.Minute):
            c.Lock()
            _, ok := c.cancelled[id]
            c.Unlock()
            if ok {
                return true, nil
            }
        case &lt;-subscriber:
            return true, nil
        }
    }</code></pre>

<pre><code class="language-go">func worker(jobsChan &lt;-chan int) {
    for job := range jobsChan {
    }
}
for i := 0; i &lt; workerPoolSize; i++ {
    go worker(jobsChan)
}</code></pre>

# worker

<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

type Consumer struct {
    inputChan chan int
    jobsChan  chan int
}

func (c *Consumer) worker(num int) {
    for job := range c.jobsChan {
        fmt.Println("worker:", num, " job value:", job)
        time.Sleep(2 * time.Second)
    }
}

func (c *Consumer) queue(input int) bool {
    fmt.Println("send input value:", input)
    // c.jobsChan &lt;- input
    select {
    case c.jobsChan &lt;- input:
        return true
    default:
        return false
    }
}

const PoolSize = 1

func main() {
    // create the consumer
    consumer := &Consumer{
        inputChan: make(chan int, 1),
        jobsChan:  make(chan int, PoolSize),
    }

    for i := 0; i &lt; PoolSize; i++ {
        go consumer.worker(i)
    }

    consumer.queue(1)
    consumer.queue(2)
    consumer.queue(3)
    consumer.queue(4)

    time.Sleep(10 * time.Second)
}</code></pre>

<pre><code class="language-go">    select {
    case &lt;-finished:
    case err := &lt;-errChannel:
        if err != nil {
            return err
        }
    }</code></pre>

<pre><code class="language-bash">send input value: 1
send input value: 2
send input value: 3
worker: 0  job value: 1
send input value: 4
worker: 0  job value: 2
worker: 0  job value: 3
worker: 0  job value: 4

send input value: 1
send input value: 2
send input value: 3
send input value: 4
worker: 0  job value: 1
worker: 0  job value: 2</code></pre>