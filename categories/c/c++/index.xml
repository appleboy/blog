<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C/C++ on 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY</title><link>https://blog.wu-boy.com/categories/c/c++/</link><description>Recent content in C/C++ on 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>appleboy.tw@gmail.com (Appleboy)</managingEditor><webMaster>appleboy.tw@gmail.com (Appleboy)</webMaster><atom:link href="https://blog.wu-boy.com/categories/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>簡報 GNU Make, Autotools, CMake 簡介</title><link>https://blog.wu-boy.com/2014/09/introduction-to-gnu-make-autotools-cmake/</link><pubDate>Fri, 12 Sep 2014 06:57:58 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2014/09/introduction-to-gnu-make-autotools-cmake/</guid><description>在 SlideShare 看到一份專門介紹 Makefile 的簡報，寫得非常詳細，在這裡紀錄並分享給大家，有在寫 C/C++ 的朋友們必看阿。搞系統(Linux / FreeBSD)管理的工程師，也是必學工具之一。</description></item><item><title>[網站] 好站連結 (八) Android, javascript, CSS, PHP, Perl, FreeBSD, Linux</title><link>https://blog.wu-boy.com/2011/04/%E7%B6%B2%E7%AB%99-%E5%A5%BD%E7%AB%99%E9%80%A3%E7%B5%90-%E5%85%AB-android-javascript-css-php-perl-freebsd-linux/</link><pubDate>Sat, 02 Apr 2011 08:54:18 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2011/04/%E7%B6%B2%E7%AB%99-%E5%A5%BD%E7%AB%99%E9%80%A3%E7%B5%90-%E5%85%AB-android-javascript-css-php-perl-freebsd-linux/</guid><description>PHP
9 Useful PHP Functions and Features You Need to Know CSS
Tips to Code Better CSS in your Projects Html5
A ROCK-SOLID DEFAULT FOR HTML5 AWESOME( Html5 模板) The Official Guide to HTML5 Boilerplate Create a Sticky Note Effect in 5 Easy Steps with CSS3 and HTML5 Git:
git-server-的兩三事 Pro Git - Table of Contents 簡體中文版 Git 初學筆記 - 實作測試 | Tsung&amp;rsquo;s Blog Javascript:</description></item><item><title>2011 OSDC Day 1 筆記</title><link>https://blog.wu-boy.com/2011/03/2011-osdc-day-1-%E7%AD%86%E8%A8%98/</link><pubDate>Thu, 31 Mar 2011 12:55:56 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2011/03/2011-osdc-day-1-%E7%AD%86%E8%A8%98/</guid><description>Update: 補上 OSDC 紀錄影片 2011.06.26 今年很高興可以北上參加 OSDC 2011 (Open Source Developers Conference)，由於之前都在南部唸書及工作，沒有機會北上參加聚會，現在人在新竹，終於有機會可以參加了，雖然早上六點就要起床趕電車了，不過到現場聽課感覺就是不同，也可以認識很多新朋友，底下來紀錄上課筆記
微軟與 jQuery 社群的親密接觸 講者: Eric Shangkuan (Microsoft) Slide: 微軟與 jQuery 社群的親密接觸 這是 OSDC 第一場演講，早上九點就開始了，雖然人不多，但是蠻多人還是為了講者而來，首先介紹什麼是 jQuery，以及 jQuery 一些基本用法，像是 CSS selector，如何在 Windows Visual Studio 上面開發 jQuery 及撰寫 plugin 整合進去 ASP.Net，最後介紹三個不錯用的 jQuery Plugin: Templeate, Datalink, Globalzation。
Templeate: 這搭配 Facebook api 可以直接做個人頁面，請參考這裡 Globalzation: 前端多國語系實做 Datalink: 可以快速處理 form，利用 object 跟 jQuery 搭配 如果要研究上述三個 jQuery Plugin 可以參考底下: jQuery Datalink: https://github.com/jquery/jquery-datalink jQuery Templeate: https://github.</description></item><item><title>[Linux] 嵌入式系統不可或缺的工具 – busybox 分析 ifconfig command</title><link>https://blog.wu-boy.com/2010/12/linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%B5%B1%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E5%B7%A5%E5%85%B7-busybox-%E5%88%86%E6%9E%90-ifconfig-command/</link><pubDate>Sun, 26 Dec 2010 16:08:07 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/12/linux-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%B5%B1%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E5%B7%A5%E5%85%B7-busybox-%E5%88%86%E6%9E%90-ifconfig-command/</guid><description>&lt;p>&lt;img src="https://i1.wp.com/www.busybox.net/images/busybox1.png?w=840" alt="Busybox" data-recalc-dims="1" />&lt;/p>
&lt;p>玩過嵌入式系統的使用者，一定都會知道 &lt;a href="http://zh.wikipedia.org/zh-tw/BusyBox">Busybox&lt;/a>，它提供一些小型 Linux command，方便在 console 端使用，以及一些 C 語言或者是 shell script 裡面，大家都知道 ifconfig 這指令，為了從 Kernel 2.6.15 轉換到 2.6.34.7 版本，原本的 Busybox 版本只有 1.0.1，現在已經到 1.18.1，轉換過程改了 Kernel &lt;a href="http://www.netfilter.org/">netfilter&lt;/a> 部份，以及 user space 部份 &lt;a href="http://netfilter.org/documentation/HOWTO/netfilter-extensions-HOWTO.html">iptables extension&lt;/a>。ifconfig 是 Busybox 其中一個指令用來查看目前有多少網路介面(network interface)，來看看他是如何得到這些 interface 資訊，包含介面名稱、type、IP Adress、IP network mask、HW address 等&amp;hellip;.。&lt;/p>
&lt;p>要讀取 interface 相關資訊可以透過兩種方式，一種是讀取 (IPv6 是 /proc/net/if_inet6)，另一種透過 Socket 連接SOCK_DGRAM，最後用 iotcl 方式讀取 interface 相關資料，busybox 會先偵測檔案 /proc/net/dev 是否存在，如果 Kernel 有支援，就會讀取此檔案，如果不存在，則利用 socket 讀取資料。&lt;/p>
&lt;p>if_readlist_proc 函式裡面:&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">&lt;code>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="1">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#1">1&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="2">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#2">2&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="3">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#3">3&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="4">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#4">4&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">&lt;code class="language-c" data-lang="c">fh = fopen_or_warn(_PATH_PROCNET_DEV, &lt;span style="color:#cd5555">&amp;#34;r&amp;#34;&lt;/span>);
&lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (!fh) {
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> if_readconf();
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看一下 /proc/net/dev 內容&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">&lt;code>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="1">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#1">1&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="2">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#2">2&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="3">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#3">3&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="4">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#4">4&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">&lt;code class="language-bash" data-lang="bash">Inter-| Receive | Transmit
face |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressed
lo: &lt;span style="color:#b452cd">104&lt;/span> &lt;span style="color:#b452cd">1&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">104&lt;/span> &lt;span style="color:#b452cd">1&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span>
eth0:21798505 &lt;span style="color:#b452cd">51360&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">7693686&lt;/span> &lt;span style="color:#b452cd">46844&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span> &lt;span style="color:#b452cd">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>[C/C++] 判斷檔案是否存在 file_exists</title><link>https://blog.wu-boy.com/2010/12/cc-%E5%88%A4%E6%96%B7%E6%AA%94%E6%A1%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-file_exists/</link><pubDate>Wed, 08 Dec 2010 04:36:48 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/12/cc-%E5%88%A4%E6%96%B7%E6%AA%94%E6%A1%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-file_exists/</guid><description>在 PHP 函式裡面，有直接 file_exists 可以使用，相當方便:
1 2 3 4 5 &amp;lt;?php if(file_exists(&amp;#34;files/appleboy.c&amp;#34;)) { echo &amp;#34;File found!&amp;#34;; } ?&amp;gt; 在 C 裡面該如何實做？有兩種方式如下:
1. 直接開檔 1 2 3 4 5 6 7 8 9 bool file_exists(const char * filename) { if (FILE * file = fopen(filename, &amp;#34;r&amp;#34;)) { fclose(file); return true; } return false; } C++ 寫法
1 2 3 4 5 6 7 8 std::fstream foo; foo.</description></item><item><title>[C/C++] 將字串轉成 16 進位</title><link>https://blog.wu-boy.com/2010/09/cc-%E5%B0%87%E5%AD%97%E4%B8%B2%E8%BD%89%E6%88%90-16-%E9%80%B2%E4%BD%8D/</link><pubDate>Mon, 13 Sep 2010 03:11:22 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/09/cc-%E5%B0%87%E5%AD%97%E4%B8%B2%E8%BD%89%E6%88%90-16-%E9%80%B2%E4%BD%8D/</guid><description>最近在碰嵌入式系統遇到一個還蠻常見的問題，我要將16進位的字串(例如 AAC2) test 轉成16進位的 unsigned int，讓我可以進行 &amp;amp; | not 一些二進位運算，底下是轉換程式，大家參考看看
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int power(int x,int n) { int i; int num = 1; for(i=1;i&amp;lt;=n;i++) num*=x; return num; } int transfer_string_to_hex(unsigned char *str_name) { char string[]=&amp;#34;0123456789ABCDEF&amp;#34;; int number[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; int i = 0; int j = 0; int str_number = 0; for(i=0; i&amp;lt;sizeof(str_name); i++) { for(j=0; j&amp;lt;sizeof(string); j++) { if(toupper(str_name&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;) == string[j]) { str_number += power(16, (sizeof(str_name)-1-i))* number[j]; break; } } } return str_number; } 由於嵌入式並沒有 pow 這個函式可以使用，所以自己寫了 power 來取代，我用在偵測網路線是否有插上：</description></item><item><title>[C/C++] cstring (string.h) 函式：strcat, strncat, strcmp, strncmp</title><link>https://blog.wu-boy.com/2010/08/cc-cstring-string-h-%E5%87%BD%E5%BC%8F%EF%BC%9Astrcat-strncat-strcmp-strncmp/</link><pubDate>Wed, 04 Aug 2010 07:29:46 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/08/cc-cstring-string-h-%E5%87%BD%E5%BC%8F%EF%BC%9Astrcat-strncat-strcmp-strncmp/</guid><description>串接函式 strcat strcat 此函式用來連接兩字串合併成單一字串，直接看底下範例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* strcat example */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main () { char str[80]; strcpy (str,&amp;#34;these &amp;#34;); strcat (str,&amp;#34;strings &amp;#34;); strcat (str,&amp;#34;are &amp;#34;); strcat (str,&amp;#34;concatenated.&amp;#34;); puts (str); return 0; } output:
1 these strings are concatenated. 看一下 strcat 原始碼：
1 2 3 4 5 6 7 8 9 char * strcat(char * __restrict s, const char * __restrict append) { char *save = s; for (; *s; ++s); while ((*s++ = *append++)); return(save); } 設定指標 save 成 source，再將 s 指標指向最後，接下來根據 append 字串一個一個往後串接，直到碰到 \0 終止 while 迴圈，最後在將指標 *save 回傳即可。</description></item><item><title>[C/C++] cstring (string.h) 搜尋函式：strstr, strchr</title><link>https://blog.wu-boy.com/2010/08/cc-cstring-string-h-%E5%87%BD%E5%BC%8F%EF%BC%9Astrstr-strchr/</link><pubDate>Tue, 03 Aug 2010 08:24:23 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/08/cc-cstring-string-h-%E5%87%BD%E5%BC%8F%EF%BC%9Astrstr-strchr/</guid><description>這次介紹 C 語言常用 string 函式：strstr，主要是針對兩個輸入參數做比對，Parameters 1 是輸入字串，Parameters 2 是找尋字串，strstr 會先將頭一次比對成功的 pointer 回傳，也就是如果要找尋 appleboyappleboy 字串中的 boy，函式會回傳第一次比對成功的 boy pointer，而並非回傳最後一個比對到的，底下是一個參考範例：
strstr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* strstr example */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main () { char str[] =&amp;#34;This is a simple string&amp;#34;; char * pch; /* 找尋 simple 字串 */ pch = strstr (str,&amp;#34;simple&amp;#34;); /* 將 simple 換成 sample */ strncpy (pch,&amp;#34;sample&amp;#34;,6); puts (str); return 0; } 看一下 Kernel 原始檔案，strstr 函式：</description></item><item><title>[網站] 好站連結 (七) Android, javascript, Css, PHP, Perl, FreeBSD, Linux</title><link>https://blog.wu-boy.com/2010/07/%E7%B6%B2%E7%AB%99-%E5%A5%BD%E7%AB%99%E9%80%A3%E7%B5%90-%E4%B8%83-android-javascript-css-php-perl-freebsd-linux/</link><pubDate>Fri, 30 Jul 2010 14:53:46 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/07/%E7%B6%B2%E7%AB%99-%E5%A5%BD%E7%AB%99%E9%80%A3%E7%B5%90-%E4%B8%83-android-javascript-css-php-perl-freebsd-linux/</guid><description>Windows C#
C# 比較字串 MSDN 比較字串 Request.Form Collection Request Query String / Form Parametrs ASP.NET QueryString Usage Using include files with ASP.NET html
[將所有 的內容包到一個
中][7] apache
Fixing mod_rewrite and .htaccess on GoDaddy Hosting javascript
jQuery Week Calendar Javascript: reference the parent window from a popup How to get and set form element values with jQuery How to check and uncheck a checkbox with jQuery Loop through parameters passed to a Javascript function perl-completion.</description></item><item><title>[C/C++] count 1 bits of input value by shifting.</title><link>https://blog.wu-boy.com/2010/05/cc-count-1-bits-of-input-value-by-shifting/</link><pubDate>Tue, 18 May 2010 14:37:40 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/05/cc-count-1-bits-of-input-value-by-shifting/</guid><description>之前寫了一篇：『[C/C++] 計算二進位任意數含有多少個位元為1?』，裡面用 n &amp;amp;= (n - 1); 的方式來計算二進位數字總共會得到多少 bit，這次來紀錄利用 shift 方式也可以得到總共含有多少 bit 數目，函式如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int count_1_bit_count(unsigned int); int main(){ int count = 0, a; a = 1023; count = count_1_bit_count(a); printf(&amp;#34;%d有%d個位元為1\n\n&amp;#34;, a, count); system(&amp;#34;pause&amp;#34;); return 0; } int count_1_bit_count(unsigned int n) { int count = 0; for(count = 0; n !</description></item><item><title>[C/C++] C語言切割字串函式 strsep，分析 URL GET 參數</title><link>https://blog.wu-boy.com/2010/04/cc-c%E8%AA%9E%E8%A8%80%E5%88%87%E5%89%B2%E5%AD%97%E4%B8%B2%E5%87%BD%E5%BC%8F-strsep%EF%BC%8C%E5%88%86%E6%9E%90-url-get-%E5%8F%83%E6%95%B8/</link><pubDate>Wed, 28 Apr 2010 03:25:44 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/04/cc-c%E8%AA%9E%E8%A8%80%E5%88%87%E5%89%B2%E5%AD%97%E4%B8%B2%E5%87%BD%E5%BC%8F-strsep%EF%BC%8C%E5%88%86%E6%9E%90-url-get-%E5%8F%83%E6%95%B8/</guid><description>&lt;p>今天來簡介 UNIX 內建的 &lt;a href="http://linux.about.com/library/cmd/blcmdl3_strsep.htm">strsep&lt;/a> 函式，這在 Windows &lt;a href="http://www.bloodshed.net/dev/devcpp.html">Dev-C++&lt;/a> 是沒有支援的，在寫 UNIX 分析字串常常需要利用到此函式，大家可以 man strsep 來看如何使用 strsep，假設我們要分析 URL Get 字串：&lt;span style="color:green">user_command=appleboy&amp;amp;test=1&amp;amp;test2=2&lt;/span>，就可以利用兩次 strsep 函式，將字串全部分離，取的個別的 name, value。strsep(stringp, delim) 第一個參數傳入需要分析的字串，第二個參數傳入 delim 符號，假設 stringp 為 NULL 字串，則函式會回傳 NULL，換句話說，strsep 會找到 stringp 字串&lt;span style="color:red">&lt;strong>第一個出現 delim 符號&lt;/strong>&lt;/span>，並將其取代為 \0 符號，然後將 stringp &lt;span style="color:red">&lt;strong>更新&lt;/strong>&lt;/span>指向到 \0 符號的下一個字串，strsep() function 回傳原來的 stringp 指標。看上面文字敘述，好像不太瞭解，沒關係，底下是 UNIX strsep.c 的原始碼：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">&lt;code>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="1">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#1"> 1&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="2">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#2"> 2&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="3">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#3"> 3&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="4">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#4"> 4&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="5">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#5"> 5&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="6">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#6"> 6&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="7">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#7"> 7&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="8">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#8"> 8&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="9">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#9"> 9&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="10">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#10">10&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="11">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#11">11&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="12">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#12">12&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="13">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#13">13&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="14">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#14">14&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="15">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#15">15&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="16">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#16">16&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="17">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#17">17&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="18">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#18">18&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="19">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#19">19&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="20">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#20">20&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="21">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#21">21&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="22">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#22">22&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="23">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#23">23&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="24">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#24">24&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="25">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#25">25&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="26">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#26">26&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="27">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#27">27&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="28">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#28">28&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="29">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#29">29&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="30">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#30">30&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="31">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#31">31&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="32">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#32">32&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="33">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#33">33&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="34">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#34">34&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="35">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#35">35&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="36">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#36">36&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="37">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#37">37&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="38">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#38">38&lt;/a>
&lt;/span>&lt;span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="39">&lt;a style="outline: none; text-decoration:none; color:inherit" href="#39">39&lt;/a>
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2">&lt;code class="language-c" data-lang="c">&lt;span style="color:#228b22">/*
&lt;/span>&lt;span style="color:#228b22"> * Get next token from string *stringp, where tokens are possibly-empty
&lt;/span>&lt;span style="color:#228b22"> * strings separated by characters from delim.
&lt;/span>&lt;span style="color:#228b22"> *
&lt;/span>&lt;span style="color:#228b22"> * Writes NULs into the string at *stringp to end tokens.
&lt;/span>&lt;span style="color:#228b22"> * delim need not remain constant from call to call.
&lt;/span>&lt;span style="color:#228b22"> * On return, *stringp points past the last NUL written (if there might
&lt;/span>&lt;span style="color:#228b22"> * be further tokens), or is NULL (if there are definitely no more tokens).
&lt;/span>&lt;span style="color:#228b22"> *
&lt;/span>&lt;span style="color:#228b22"> * If *stringp is NULL, strsep returns NULL.
&lt;/span>&lt;span style="color:#228b22"> */&lt;/span>
&lt;span style="color:#00688b;font-weight:bold">char&lt;/span> *
&lt;span style="color:#008b45">strsep&lt;/span>(stringp, delim)
&lt;span style="color:#00688b;font-weight:bold">char&lt;/span> **stringp;
&lt;span style="color:#8b008b;font-weight:bold">const&lt;/span> &lt;span style="color:#00688b;font-weight:bold">char&lt;/span> *delim;
{
&lt;span style="color:#00688b;font-weight:bold">char&lt;/span> *s;
&lt;span style="color:#8b008b;font-weight:bold">const&lt;/span> &lt;span style="color:#00688b;font-weight:bold">char&lt;/span> *spanp;
&lt;span style="color:#00688b;font-weight:bold">int&lt;/span> c, sc;
&lt;span style="color:#00688b;font-weight:bold">char&lt;/span> *tok;
&lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> ((s = *stringp) == &lt;span style="color:#658b00">NULL&lt;/span>)
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> (&lt;span style="color:#658b00">NULL&lt;/span>);
&lt;span style="color:#8b008b;font-weight:bold">for&lt;/span> (tok = s;;) {
c = *s++;
spanp = delim;
&lt;span style="color:#8b008b;font-weight:bold">do&lt;/span> {
&lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> ((sc = *spanp++) == c) {
&lt;span style="color:#8b008b;font-weight:bold">if&lt;/span> (c == &lt;span style="color:#b452cd">0&lt;/span>)
s = &lt;span style="color:#658b00">NULL&lt;/span>;
&lt;span style="color:#8b008b;font-weight:bold">else&lt;/span>
s[-&lt;span style="color:#b452cd">1&lt;/span>] = &lt;span style="color:#b452cd">0&lt;/span>;
*stringp = s;
&lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> (tok);
}
} &lt;span style="color:#8b008b;font-weight:bold">while&lt;/span> (sc != &lt;span style="color:#b452cd">0&lt;/span>);
}
&lt;span style="color:#228b22">/* NOTREACHED */&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>[C/C++] strpbrk 在字串中找尋指定的符號或字母</title><link>https://blog.wu-boy.com/2010/04/cc-strpbrk-%E5%9C%A8%E5%AD%97%E4%B8%B2%E4%B8%AD%E6%89%BE%E5%B0%8B%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AC%A6%E8%99%9F%E6%88%96%E5%AD%97%E6%AF%8D/</link><pubDate>Thu, 01 Apr 2010 15:19:04 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/04/cc-strpbrk-%E5%9C%A8%E5%AD%97%E4%B8%B2%E4%B8%AD%E6%89%BE%E5%B0%8B%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AC%A6%E8%99%9F%E6%88%96%E5%AD%97%E6%AF%8D/</guid><description>繼上一篇：『[C/C++] 切割字串函數：strtok, Network mac address 分割』，內容寫到 Microsoft 用到 strpbrk 來找尋字串中特定符號，並且回傳該符號的位址，用法如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &amp;#34;string.h&amp;#34;#include &amp;#34;stdlib.h&amp;#34;#include &amp;#34;stdio.h&amp;#34; int main () { char str[] = &amp;#34;This is a sample string&amp;#34;; char key[] = &amp;#34;aeiou&amp;#34;; char * pch; printf (&amp;#34;Vowels in &amp;#39;%s&amp;#39;: &amp;#34;,str); pch = strpbrk (str, key); while (pch != NULL) { printf (&amp;#34;%c &amp;#34; , *pch); /* 也可以直接輸出字串 */ printf(&amp;#34;\noutput=%s\n&amp;#34;, pch); pch = strpbrk (pch+1,key); } printf (&amp;#34;\n&amp;#34;); system(&amp;#34;pause&amp;#34;); return 0; } 輸出結果：</description></item><item><title>[C/C++] 切割字串函數：strtok, Network mac address 分割</title><link>https://blog.wu-boy.com/2010/04/cc-%E5%88%87%E5%89%B2%E5%AD%97%E4%B8%B2%E5%87%BD%E6%95%B8%EF%BC%9Astrtok-network-mac-address-%E5%88%86%E5%89%B2/</link><pubDate>Thu, 01 Apr 2010 14:16:57 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/04/cc-%E5%88%87%E5%89%B2%E5%AD%97%E4%B8%B2%E5%87%BD%E6%95%B8%EF%BC%9Astrtok-network-mac-address-%E5%88%86%E5%89%B2/</guid><description>今天寫了 strtok 的範例：『如何分離網路 mac address』程式碼如下，大家一定會有疑問 strtok 第一次呼叫，第一參數輸入愈分離的字串，在 while 迴圈，則是輸入 NULL 呢？底下就來解析 strtok.c 的程式碼。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* * * Author : appleboy * Date : 2010.04.01 * Filename : strtok.c * */ #include &amp;#34;string.h&amp;#34;#include &amp;#34;stdlib.h&amp;#34;#include &amp;#34;stdio.h&amp;#34; int main() { char str[]=&amp;#34;00:22:33:4B:55:5A&amp;#34;; char *delim = &amp;#34;:&amp;#34;; char * pch; printf (&amp;#34;Splitting string \&amp;#34;%s\&amp;#34;into tokens:\n&amp;#34;,str); pch = strtok(str,delim); while (pch !</description></item><item><title>[C/C++] 計算二進位任意數含有多少個位元為1?</title><link>https://blog.wu-boy.com/2010/02/cc-%E8%A8%88%E7%AE%97%E4%BA%8C%E9%80%B2%E4%BD%8D%E4%BB%BB%E6%84%8F%E6%95%B8%E5%90%AB%E6%9C%89%E5%A4%9A%E5%B0%91%E5%80%8B%E4%BD%8D%E5%85%83%E7%82%BA1/</link><pubDate>Wed, 24 Feb 2010 15:17:17 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/02/cc-%E8%A8%88%E7%AE%97%E4%BA%8C%E9%80%B2%E4%BD%8D%E4%BB%BB%E6%84%8F%E6%95%B8%E5%90%AB%E6%9C%89%E5%A4%9A%E5%B0%91%E5%80%8B%E4%BD%8D%E5%85%83%E7%82%BA1/</guid><description>今天看到一個有趣的題目，就是計算二進位任意數值，其中包含了幾個1，這非常有趣，利用每個 bit 做&amp;amp;就可以解出這個問題了:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int bitcount(unsigned int); int main(){ int count = 0, a; a = 1023; count = bitcount(a); printf(&amp;#34;%d有%d個位元為1\n\n&amp;#34;, a, count); system(&amp;#34;pause&amp;#34;); return 0; } int bitcount(unsigned int n) { int count = 0 ; while (n) { count++ ; n &amp;amp;= (n - 1) ; //關鍵演算之處 } return count ; } 關鍵解法是在 n &amp;amp;= (n - 1) ; 這個地方，為什麼會是這樣寫呢，大家可以想看看，為什麼要 (n-1)，其實可以帶數字進去跑看看就知道程式為什麼會這樣寫，這個 case 可以分作兩種，數值可能會有兩種狀況，一種是奇數，另一種就是偶數，8 代表 1000，9 代表 1001，最右邊 bit 是 1 代表奇數，剩下的都是偶數，拿9當例子帶入 while 迴圈試試看，首先將 count + 1，接下來 1001 會跟 1000 做相乘動作，就會變成 1000，接下來跑另一次 while 會變成 1000 &amp;amp; 0111 就會變成 0 了，退出 while 迴圈，所以結論是 (n -1) 的用意是去掉一個 1 位元 bit，就像 [xxxx10 &amp;hellip; 0] -1 = [xxxx01 &amp;hellip; 1] &amp;hellip;.</description></item><item><title>[C/C++] 指標相加 = ？or 相減 = offset</title><link>https://blog.wu-boy.com/2010/02/cc-%E6%8C%87%E6%A8%99%E7%9B%B8%E5%8A%A0-%EF%BC%9For-%E7%9B%B8%E6%B8%9B-offset/</link><pubDate>Mon, 08 Feb 2010 06:50:16 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2010/02/cc-%E6%8C%87%E6%A8%99%E7%9B%B8%E5%8A%A0-%EF%BC%9For-%E7%9B%B8%E6%B8%9B-offset/</guid><description>最近看到網路上討論 C/C++ 題目，某公司主管給新進人員面試的 C/C++ 考題，如下：
1 2 3 4 5 6 7 8 int main(void) { int *a,*b; a=1; b=1; printf(&amp;#34;%d\n&amp;#34;,a+b); return 0; } 請問上面這個題目，哪裡有出問題，這是面試官問新進人員的題目之一，看也知道這程式丟到 Dev-C++ 是不會過的，a b 都是宣告為整數指標型態，可是在 a=1 或 b=1 在 Dev-C++ 裡面是編譯不過的，但是那寫法是沒有錯的，就像你設定 a=0 或者是 a=NULL 是一樣意思，不過最好是不要這樣寫，assignment 這樣寫不太好，可以改成 a = (int )1; b = (int )1; 這樣就可以順利編譯通過，再來 printf(&amp;quot;%d\n&amp;quot;,a+b); 這行錯很大，指標相加會爆炸吧，如果程式這樣寫，不把 OS 搞掛，那我還會覺得懷疑呢，正確寫法是指標加上 offset(位移)，這樣才是可以正確執行的，所以我們把程式改成下面：
1 2 3 4 5 6 7 8 int main(void) { int *a,*b; a = (int *)1; b = (int *)1; printf(&amp;#34;%d\n&amp;#34;,a+(int)b); return 0; } 最後的執行結果是 5，(int) b 就相當於 sizeof(b) 也等於 sizeof(int ) 答案都是四，所以就是 1+4 =5，指標是不能相加的，只能透過 offset 方式來讓指標指向不同 base，但是如果是指標相減，那就是求 offset 的意思喔，看一下底下例子</description></item><item><title>[C/C++] 實做 C 語言 substr 功能，模擬計算機功能</title><link>https://blog.wu-boy.com/2008/03/cc-%E5%AF%A6%E5%81%9A-c-%E8%AA%9E%E8%A8%80-substr-%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%A8%A1%E6%93%AC%E8%A8%88%E7%AE%97%E6%A9%9F%E5%8A%9F%E8%83%BD/</link><pubDate>Mon, 17 Mar 2008 14:05:12 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2008/03/cc-%E5%AF%A6%E5%81%9A-c-%E8%AA%9E%E8%A8%80-substr-%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%A8%A1%E6%93%AC%E8%A8%88%E7%AE%97%E6%A9%9F%E5%8A%9F%E8%83%BD/</guid><description>&lt;p>前天在幫學弟寫程式，寫一個計算機程式，題目如下：&lt;/p>
&lt;blockquote>
&lt;p>寫一程式模擬簡單的計算機 每個資料列含下列的運算子中的一個及其右運算元 假設左運算元存在累加器中(初值為0) 需要函式scan_data 有2個輸出參數回傳 從資料列讀入的運算子元和右運算元 亦需函式do_next_op 執行運算子的功能 此函式有2個輸入參數(運算子和運算元) 及一個輸入/輸出參數(累加器) 有效運算子有 + 加 – 減 * 乘 / 除 ^ 次方 q 結束 此計算器在每次運算後要顯示累加器之值 一個執行範例如下 +5.0 result so far is 5.0 ^2 result so far is 25.0 /2.0 result so far is 12.5 q0 final ressult is 12.5
上面是我學弟的題目，不過他有傳一份他朋友的作業給我看，我本身不太喜歡用 scanf，我比較喜歡用 fgets，但是後來遇到要切割文字的問題，也就是 C 語言沒有 substr 取字串的函式，所以利用底下來實做：&lt;/p>
&lt;/blockquote></description></item><item><title>[C/C++] 判斷字串是否為數字</title><link>https://blog.wu-boy.com/2008/03/cc-%E5%88%A4%E6%96%B7%E5%AD%97%E4%B8%B2%E6%98%AF%E5%90%A6%E7%82%BA%E6%95%B8%E5%AD%97/</link><pubDate>Sat, 01 Mar 2008 08:39:09 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2008/03/cc-%E5%88%A4%E6%96%B7%E5%AD%97%E4%B8%B2%E6%98%AF%E5%90%A6%E7%82%BA%E6%95%B8%E5%AD%97/</guid><description>&lt;p>常常在寫 C 語言，有時候想判斷輸入的是否為數字，如果不是的話，要重新輸入，所以寫一下怎麼判斷的，ptt提供了下面很多函式&lt;/p>
&lt;blockquote>
&lt;p>isalnum ctype.h 測試某一整數值是否為’A’-‘Z’,’a’-‘z’,’0′-‘9’等文數字之一。 isalpha ctype.h 測試某一整數值是否為’A’-‘Z’,’a’-‘z’,等字母之一。 isascii ctype.h 如果ch的值判於0-127，則傳回非零整數(0x00-0x7F)。 iscntrl ctype.h 如果ch是一刪除字元或一般控制字元，則傳回非零整數(0x7F或0x00-0x1F)。 isdigit ctype.h 如果ch是一數字，則傳回非零整數。 isgraph ctype.h 如果ch是為可列印字元，則傳回非零整數。 islower ctype.h ch若為小寫字母，則傳回非零整數。 isprint ctype.h ch若為可列印字元，則傳回非零整數。其功能與isgraph相似。 ispunct ctype.h ch若為標點符號，則傳回非零整數。 isspace ctype.h ch若為空白字元或定位字元(Tab)，歸位字元(Enter鍵)，新列字元，垂直定位字元，換頁字元，則傳回非零整數。 isupper ctype.h ch若為大寫字母，則傳回非零整數。 isxdigit ctype.h ch若為一個十六進位數字，則傳回非零整數
用程式去判斷會更快，因為上面的函式，都是要單一字元去檢查，非常不方便，所以就寫了底下的程式&lt;/p>
&lt;/blockquote></description></item><item><title>[C/C++] 判斷年份是否閏年</title><link>https://blog.wu-boy.com/2008/02/cc-%E5%88%A4%E6%96%B7%E5%B9%B4%E4%BB%BD%E6%98%AF%E5%90%A6%E9%96%8F%E5%B9%B4/</link><pubDate>Sat, 01 Mar 2008 05:57:04 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2008/02/cc-%E5%88%A4%E6%96%B7%E5%B9%B4%E4%BB%BD%E6%98%AF%E5%90%A6%E9%96%8F%E5%B9%B4/</guid><description>無聊幫同學寫作業，其實這還蠻簡單的，判斷閏年的方法如下
1、可以被4整除但不可以被100整除。 2、可以被400整除。
程式碼如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int leap(int year); int leap(int year) { if((year%4)==0 &amp;amp;&amp;amp; (year%100)!=0 || (year%400) ==0) { printf (&amp;#34;%d是閏年\n&amp;#34;,year); } else { printf (&amp;#34;%d不是閏年\n&amp;#34;,year); } } int main(int argc,char *argv[]) { char *p; char year[20]; printf(&amp;#34;請輸入您要查詢的年份『輸入exit離開』: &amp;#34;); while(fgets(year, sizeof(year), stdin)) { if ((p = strchr(year, &amp;#39;\n&amp;#39;)) !</description></item><item><title>[C/C++] 如何計算陣列大小/個數</title><link>https://blog.wu-boy.com/2008/02/cc-%E5%A6%82%E4%BD%95%E8%A8%88%E7%AE%97%E9%99%A3%E5%88%97%E5%A4%A7%E5%B0%8F%E5%80%8B%E6%95%B8/</link><pubDate>Mon, 04 Feb 2008 06:50:37 +0000</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2008/02/cc-%E5%A6%82%E4%BD%95%E8%A8%88%E7%AE%97%E9%99%A3%E5%88%97%E5%A4%A7%E5%B0%8F%E5%80%8B%E6%95%B8/</guid><description>最近在寫 BCB 的時候遇到的，不過忘記之前怎麼寫的，所以又上去找了一下，發現可以利用 sizeof 這個函式，來計算陣列的個數，我去查了一下 BCB 的 manual，裡面寫的還蠻詳細的，如下
Example for sizeof operator
/ USE THE sizeof OPERATOR TO GET SIZES OF DIFFERENT DATA TYPES. /
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &amp;lt;stdio.h&amp;gt;struct st { char *name; int age; double height; }; struct st St_Array[]= { /* AN ARRAY OF structs */ { &amp;#34;Jr.</description></item></channel></rss>