<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Design on 小惡魔 - AppleBOY</title><link>https://blog.wu-boy.com/categories/system-design/</link><description>Recent content in System Design on 小惡魔 - AppleBOY</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>appleboy.tw@gmail.com (Appleboy)</managingEditor><webMaster>appleboy.tw@gmail.com (Appleboy)</webMaster><lastBuildDate>Fri, 23 Dec 2022 08:32:31 +0800</lastBuildDate><atom:link href="https://blog.wu-boy.com/categories/system-design/feed.xml" rel="self" type="application/rss+xml"/><item><title>系統設計: 如何取消正在執行的工作任務</title><link>https://blog.wu-boy.com/2022/12/system-design-how-to-cancel-a-running-task-in-golang/</link><pubDate>Fri, 23 Dec 2022 08:32:31 +0800</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2022/12/system-design-how-to-cancel-a-running-task-in-golang/</guid><description>本篇來聊聊『如何取消正在執行的工作任務』，當系統內有需要處理比較久或較多資源的任務，肯定會將這些任務丟到其他機器再執行，執行過程如果需要取消，會經過如上圖幾個步驟。先假設中間的過程不透過 Message Queue 機制，而是兩個服務進行溝通透過 RESTful 或 gRPC 方式。
使用情境 可以看到步驟一是 worker 會先發一個請求到後端服務，詢問說現在正在執行的任務是否需要取消，這邊可以用一個長連接，或許是 30 秒或 1 分鐘才斷線。步驟二是 User 從 Web UI 端按下取消的按鈕。步驟三是後端服務接受到取消任務的請求，拿到請求後，就回覆給 Worker 取消任務。
大家可以想看看這樣的情境該如何設計此流程，先不考慮多台後端服務的情境，也不考慮使用 Message Queue 的方式來實作。也許大家有想到一種方式，就是當使用者按下取消時 (到步驟三)，後端服務就將此任務的狀態改成取消。而 Worker 每次來詢問狀態 (步驟一)，這樣後端就在查詢一次就可以了 (步驟四)，這方式也沒有不對，但是即時性效果比較差，如果是每 30 秒輪詢一次，就有可能 30 秒後才能取消任務，輪詢時間設定很短，又會造成過多不必要的連線請求。除了這種方式外，還有沒有其他方式可以不需要查詢資料庫就可以即時讓 Worker 知道目前任務狀態。
單機實作方式 用 Go 語言來處理後端跟 Worker 之間的資料交換機制。可以看下圖，先實作 canceller package，裡面有兩個不同的 Method，一個是 Cancel 用來處裡接受使用者取消哪一筆任務，另一個是 Cancelled 用來接受 Worker 的請求。
這邊先考慮單個後端服務，設計 canceller 結構可以用 map 方式來紀錄目前有多少 worker 請求，其中 map 內的 string 用來記錄任務唯一 ID 識別。
1 2 3 4 5 6 7 8 9 10 11 type canceler struct { sync.</description></item><item><title>系統設計: 處理服務讀取多個任務遇到的問題 (Go 語言)</title><link>https://blog.wu-boy.com/2022/11/simple-scheduler-with-multiple-worker-using-golang/</link><pubDate>Sun, 13 Nov 2022 08:23:09 +0800</pubDate><author>appleboy.tw@gmail.com (Appleboy)</author><guid>https://blog.wu-boy.com/2022/11/simple-scheduler-with-multiple-worker-using-golang/</guid><description>&lt;p>&lt;img src="https://i.imgur.com/lbY6KzL.png" alt="system design 02">&lt;/p>
&lt;p>不同的服務都會有需要處理比較久的任務，這些任務是不能即時執行完成，才回應給前端，這樣使用者體驗會非常的差。將類型的任務存在資料庫或放在&lt;a href="https://zh.m.wikipedia.org/zh-hant/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息對列&lt;/a>就是一種處理方式，接著啟動另一個服務來消化非即時性的任務，而常見的處理方式就是在服務內啟動多個 Worker Node 來平行消化任務 (如上圖)。&lt;/p></description></item></channel></rss>